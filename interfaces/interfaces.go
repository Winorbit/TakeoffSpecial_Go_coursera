package main
 
import "fmt"

/*
Допустим, мы разработываем игру, РПГ с открытым миром. 
В игре у нас будет много взаимодействия с разными персонажми - бои с врагами, диалоги с квестовыми героями, торгвля, етс.

Но если у нас РПГ вроде Deus Ex, где мир прибилжен к нашему, то почти все персонажи - люди.
У них есть набор одинаковых значений и умений - перевижение, диалог, атака.  
То есть - один шаблон. Поэтому мы можем опрееделить схему, каркас, на основании которой построим уникальные сущности.

Например, с каждым из персонажей ожно взаимоедйствовать, но по разному.
Горожане отвечают на попытку пообщаться стандартными фразами.
Квествые герои открывают диалог.
Торговцы переходят в режим торговли.

Поэтому мы можем изначально записать один шаблон или ИНТЕРФЕЙС - interract, взаимодействие. А затем, для каждого класса, опрделить его индвидуально.
*/


/*
NPC - общая заготовка под любого героя, хоть врага, хоть торговца.
И с каждым из них можно ВЗАИМОДЕЙСТВОВАТЬ. А вот результат взаимодействия - у каждого будет свой.
*/
type NPC interface{
    interract()
}

 
// Опишем ТОРГОВЦА
type Dealer struct{
    Name string
    Spec string
    Items []string
}
 
// Здесь просто горожанин, с ним нет взаимодействий, поэтому у него другая, более простая структура.
type Citizen struct{
    Name string
}

type Mob struct{
    Name string
    WeaponID int
    WeaponName string
}
 

// А вот тут уже опишем то, как работает наше ВЗАИМОДЕЙСТВИЕ, interract. Здесь будет interract именно Горожанина.
func (c Citizen) interract(){
    fmt.Println("Остановись и послушай!")
}


// А вот тут совсем иной - для торговца
func (d Dealer) interract(){

    fmt.Println("Сообщение о начале торговли")
    fmt.Printf("Торговец показывает экран со своими предметами: %v", d.Items)
}
 
func main() {
     
    var decardKain NPC = Citizen{Name: "Decar Kain"}
    var Diego NPC = Dealer{Name: "Diego",
                           Spec: "Armor",
                           Items: []string{"Dragon hunter sword", "Orc sword", "Sword of Innos"}}
    decardKain.interract()
    Diego.interract()
}

/*
Т.е мы создаем объект, который создается на основе ИНТЕРФЕЙСА. И мы крепим наш type к этому интерфейсу.
Затем идет проверки - прикреплен ли метод, объявленный в интерфейсе, к этому type.
*/

var decardKain NPC = Citizen{Name: "Decar Kain"}
var butcher NPC = Mob{Name: "Butcher", WeaponID:34812, WeaponName: "Butcher Sword"}

/*
NPC - это интерфейс.
Мы создает  объект, созданный из type Citizen.
И нужно, чтоб у этого Citizen был метод, объявленный в NPC
*/

// Реализация интерфейсов, вложенные интерфейсы
// Пример на Питоне, расказа ро гексогонльную архитектуру
// https://metanit.com/go/tutorial/6.1.php
// Полиморфизм